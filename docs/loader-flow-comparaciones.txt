Comparaciones de flujo de loaders (Interface-2 vs flujo recomendado)
===============================================================

Fecha: 2026-02-19
Referencia interna revisada en cÃ³digo:
- src-tauri/src/app/launcher_service.rs
- src-tauri/src/services/instance_builder.rs
- src-tauri/src/app/instance_service.rs
- src-tauri/src/services/loader_installer.rs
- src-tauri/src/domain/loaders/* (installer/resolver)

Resumen ejecutivo
-----------------
1) Vanilla: actualmente sÃ­ estÃ¡ implementado de forma funcional (descarga version.json, libraries, assets, classpath y launch). âœ…
2) Fabric/Quilt/Forge/NeoForge: no se observa un instalador de loader ejecutÃ¡ndose realmente durante creaciÃ³n o pre-launch. âŒ
3) For ge/NeoForge: no hay ejecuciÃ³n visible de processors del installer (paso crÃ­tico), por eso es esperable fallo por BootstrapLauncher faltante. âŒ
4) El sistema sÃ­ hace merge por inheritsFrom en runtime, pero depende de que exista un version.json de loader vÃ¡lido en disco; hoy no se genera ese artefacto por el flujo actual. âš ï¸

ComparaciÃ³n detallada por loader
--------------------------------

ğŸŸ¢ VANILLA (referencia base)
Esperado:
- Descargar versiÃ³n vanilla
- Descargar libraries
- Descargar assets
- Construir classpath
- Lanzar con Java embebido
- mainClass = net.minecraft.client.main.Main

Actual en Interface-2:
- build_instance_structure descarga version.json oficial + client.jar + libraries + assets.
- validate_launch prepara classpath y lanza con Java embebido.
- Se resuelven args desde JSON.
=> Resultado: alineado, por eso vanilla funciona.

ğŸŸ£ FABRIC
Esperado:
- Resolver vanilla base
- Obtener metadata loader
- Descargar fabric-loader + intermediary + libs fabric
- Fusionar con vanilla
- Leer version.json fabric
- Construir classpath (vanilla libs + fabric jars + client jar)
- mainClass desde JSON (normalmente KnotClient)

Actual en Interface-2:
- No se observa instalaciÃ³n real de Fabric durante create_instance.
- loader_installer.rs estÃ¡ vacÃ­o de lÃ³gica efectiva.
- domain/loaders/fabric/* aparece solo con placeholders/comentarios.
- Se persiste metadata.loader, pero no se generan artefactos de loader por ese dato.
=> Brecha principal: faltan descarga y generaciÃ³n de version.json de Fabric.

ğŸ”µ QUILT
Esperado:
- Similar a Fabric con metadata de Quilt
- Merge manifests
- mainClass desde JSON Quilt

Actual:
- Mismo problema que Fabric: no existe pipeline real de instalaciÃ³n/resoluciÃ³n.
- No se detecta generaciÃ³n de JSON ejecutable de Quilt.
=> Brecha principal: pipeline ausente.

ğŸŸ  FORGE (1.13+)
Esperado:
- Descargar installer Forge
- Ejecutar processors del installer (obligatorio)
- Generar libraries forge + version.json generado
- Leer args JVM/Game desde JSON (ej: --launchTarget forgeclient)
- mainClass desde JSON (frecuente BootstrapLauncher)

Actual:
- No hay ejecuciÃ³n de installer/processors en el flujo revisado.
- No aparece extracciÃ³n de args especÃ­ficos forge desde un JSON de forge generado por processors.
- Resultado tÃ­pico esperado: ClassNotFoundException de BootstrapLauncher.
=> Brecha principal: falta paso de processors y consumo de JSON generado.

ğŸ”µ NEOFORGE
Esperado:
- Igual que Forge moderno: installer + processors + JSON generado + args JVM del JSON

Actual:
- Mismo gap crÃ­tico que Forge.
- Sin processors no se arma el classpath correcto de bootstrap y librerÃ­as.
=> Brecha principal: falta instalaciÃ³n real del loader + processors.

Hallazgos tÃ©cnicos transversales
--------------------------------
1) load_merged_version_json (runtime) sÃ­ soporta inheritsFrom recursivo.
   Esto ayuda, pero solo funciona si ya existe un Ã¡rbol de version.json de loader vÃ¡lido en disco.

2) validate_launch en instance_service aÃºn verifica explÃ­citamente la clase
   net.minecraft.client.main.Main dentro del jar ejecutable.
   Para loaders modernos este check puede ser incorrecto si el entrypoint real viene de loader JSON.

3) El classpath final se arma como [libraries resueltas] + [client.jar],
   que es vÃ¡lido para vanilla; para Forge/NeoForge depende totalmente de que esas libraries
   ya hayan sido generadas por installer/processors (hoy no se ve ese paso).

QuÃ© estÃ¡ mal hoy (concreto)
---------------------------
- Se guarda metadata de loader, pero no se ejecuta pipeline de instalaciÃ³n real por loader.
- No hay processors de Forge/NeoForge.
- No se construyen artefactos/JSON especÃ­ficos por loader durante create_instance.
- La validaciÃ³n de main class estÃ¡ sesgada a vanilla.

RecomendaciÃ³n de implementaciÃ³n (arquitectura mÃ­nima)
------------------------------------------------------
Implementar un flujo real por fases:

resolve_instance()
  â”œâ”€ resolve_vanilla()
  â”œâ”€ resolve_loader(loader, version)
  â”‚    â”œâ”€ fabric/quilt: descargar metadata + libs + version json
  â”‚    â””â”€ forge/neoforge: descargar installer + ejecutar processors + generar json/libs
  â”œâ”€ merge_version_json()
  â”œâ”€ build_classpath()
  â””â”€ launch_with_embedded_java()

Checklist de logs recomendado
-----------------------------
Imprimir en validaciÃ³n/lanzamiento:
- JAVA ejecutado
- VERSION JSON efectivo usado
- MAIN CLASS efectiva
- tamaÃ±o del classpath
- primeros N jars del classpath

Si MAIN CLASS termina en net.minecraft.client.main.Main para una instancia con loader,
estÃ¡s arrancando vanilla o un merge incorrecto.

