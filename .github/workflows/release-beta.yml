name: Release Beta (Tauri)

on:
  push:
    tags:
      - "v*.*.*-beta.*"

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - uses: dtolnay/rust-toolchain@stable

      - name: Prepare npm config (public registry, no auth)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $npmrc = Join-Path $env:RUNNER_TEMP "ci.npmrc"
          @"
          registry=https://registry.npmjs.org/
          always-auth=false
          "@ | Out-File -FilePath $npmrc -Encoding ascii -NoNewline
          "NPM_CONFIG_USERCONFIG=$npmrc" >> $env:GITHUB_ENV

      - name: Install deps
        env:
          NODE_AUTH_TOKEN: ""
        run: npm ci

      - name: Verify Windows bundle icon
        shell: pwsh
        run: |
          if (-not (Test-Path "src-tauri/icons/icon.ico")) { throw "Missing required NSIS icon: src-tauri/icons/icon.ico" }

      - name: Build + Release (prerelease)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: ${{ github.ref_name }}
          releaseDraft: false
          prerelease: true
          args: --bundles nsis

      - name: Collect Tauri updater bundles (NSIS preferred, MSI optional)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $bundleRoot = "src-tauri\target\release\bundle"
          $outDir = "updater-bundles"
          New-Item -ItemType Directory -Force $outDir | Out-Null

          Write-Host "=== Bundle tree (for debug) ==="
          Get-ChildItem -Recurse $bundleRoot | Select-Object FullName | Sort-Object FullName

          $nsisZip = Get-ChildItem -Recurse $bundleRoot -Filter "*.nsis.zip" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nsisZip) {
            $nsisExe = Get-ChildItem -Recurse $bundleRoot -Filter "*-setup.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $nsisExe) { throw "No NSIS installer (*-setup.exe) found under $bundleRoot" }

            # Fallback: crear zip con Deflate estándar (método 8) via .NET explícito.
            # NUNCA usar Compress-Archive: puede producir métodos de compresión no soportados
            # por el crate zip de Tauri (Deflate64, SmallestSize, etc.).
            $zipPath = Join-Path $nsisExe.Directory.FullName ($nsisExe.BaseName + ".nsis.zip")
            Add-Type -AssemblyName System.IO.Compression
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            $stream = [System.IO.File]::Open($zipPath, [System.IO.FileMode]::Create)
            try {
              $archive = [System.IO.Compression.ZipArchive]::new($stream, [System.IO.Compression.ZipArchiveMode]::Create, $false)
              try {
                $entry = $archive.CreateEntry($nsisExe.Name, [System.IO.Compression.CompressionLevel]::Optimal)
                $entryStream = $entry.Open()
                $fileStream = [System.IO.File]::OpenRead($nsisExe.FullName)
                $fileStream.CopyTo($entryStream)
                $fileStream.Dispose()
                $entryStream.Dispose()
              } finally { $archive.Dispose() }
            } finally { $stream.Dispose() }

            # Verificar que el ZIP producido usa Deflate (método 8), no Deflate64 ni otro.
            $rawBytes = [System.IO.File]::ReadAllBytes($zipPath)
            $method = [System.BitConverter]::ToUInt16($rawBytes, 8)
            if ($method -ne 8 -and $method -ne 0) {
              throw "Fallback ZIP usa método de compresión $method (esperado: 8=Deflate o 0=Store). El updater nativo de Tauri lo rechazaría."
            }
            Write-Host "Fallback ZIP creado con método $method (Deflate). OK."

            $nsisZip = Get-Item $zipPath
            Write-Host "Created fallback updater zip: $($nsisZip.FullName)"
          }

          $nsisDest = Join-Path $outDir $nsisZip.Name
          Copy-Item $nsisZip.FullName $nsisDest -Force
          Write-Host "Using updater bundle: $nsisDest"

          $msiZip = Get-ChildItem -Recurse $bundleRoot -Filter "*.msi.zip" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($msiZip) {
            $msiDest = Join-Path $outDir $msiZip.Name
            Copy-Item $msiZip.FullName $msiDest -Force
            Write-Host "Also collected MSI updater zip: $msiDest"
          }

          $finalZips = Get-ChildItem $outDir -Filter *.zip
          if (-not $finalZips -or $finalZips.Count -eq 0) { throw "No updater zip bundles were produced in $outDir" }

          Write-Host "Collected updater artifacts:"
          Get-ChildItem $outDir

      - name: Verify ZIP compression method (must be Deflate=8 or Store=0)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $zips = Get-ChildItem 'updater-bundles' -Filter *.zip
          if (-not $zips) { throw 'No zips found in updater-bundles' }
          foreach ($z in $zips) {
            $raw = [System.IO.File]::ReadAllBytes($z.FullName)
            if ($raw[0] -ne 0x50 -or $raw[1] -ne 0x4B -or $raw[2] -ne 0x03 -or $raw[3] -ne 0x04) {
              throw "$($z.Name): not a valid ZIP (missing PK\x03\x04 header). El archivo no es un ZIP real."
            }
            $method = [System.BitConverter]::ToUInt16($raw, 8)
            Write-Host "$($z.Name): compression method = $method"
            if ($method -ne 8 -and $method -ne 0) {
              throw "$($z.Name): metodo de compresion $method no soportado por tauri-plugin-updater. Solo se aceptan 0=Store o 8=Deflate."
            }
            Write-Host "  -> OK (Deflate/Store)"
          }

      - name: Write signing key to disk (raw minisign)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          New-Item -ItemType Directory -Force "$env:RUNNER_TEMP\tauri" | Out-Null
          $keyPath = "$env:RUNNER_TEMP\tauri\signing.key"

          @'
          ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_RAW }}
          '@ | Out-File -FilePath $keyPath -Encoding ascii -NoNewline

          echo "TAURI_KEY_PATH=$keyPath" >> $env:GITHUB_ENV

      - name: Sign updater-bundles zips
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"
          $keyPath = "$env:TAURI_KEY_PATH"
          if (-not (Test-Path $keyPath)) { throw "Signing key not found: $keyPath" }

          $bundles = Get-ChildItem "updater-bundles" -Filter *.zip
          if (-not $bundles) { throw "No updater-bundles/*.zip found" }

          foreach ($b in $bundles) {
            Write-Host "Signing $($b.Name)"
            npx tauri signer sign --private-key-path "$keyPath" "$($b.FullName)"
            if (-not (Test-Path "$($b.FullName).sig")) { throw "Missing sig for $($b.Name)" }
          }

          Get-ChildItem "updater-bundles"

      - name: Upload updater bundles + sigs
        uses: softprops/action-gh-release@v2
        with:
          files: |
            updater-bundles/*.msi.zip
            updater-bundles/*.msi.zip.sig
            updater-bundles/*.nsis.zip
            updater-bundles/*.nsis.zip.sig

      - name: Generate beta manifest
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'

          $tag = "${{ github.ref_name }}"
          $repo = "${{ github.repository }}"
          $api = "https://api.github.com/repos/$repo/releases/tags/$tag"
          $headers = @{ Authorization = "Bearer $env:GITHUB_TOKEN"; "User-Agent" = "gh-actions" }

          $release = Invoke-RestMethod -Headers $headers -Uri $api

          $windowsUpdaterAssets = $release.assets | Where-Object {
            $_.name -match '(?i)\.(nsis|msi)\.zip$' -and
            ($_.name -match '(?i)x64|x86_64|amd64' -or $_.name -notmatch '(?i)arm64|aarch64')
          }

          $updaterAsset = $windowsUpdaterAssets | Where-Object {
            $_.name -match '(?i)\.nsis\.zip$' -and $_.name -match '(?i)x64|x86_64|amd64'
          } | Select-Object -First 1

          if (-not $updaterAsset) {
            $updaterAsset = $windowsUpdaterAssets | Where-Object {
              $_.name -match '(?i)\.nsis\.zip$'
            } | Select-Object -First 1
          }

          if (-not $updaterAsset) {
            $updaterAsset = $windowsUpdaterAssets | Where-Object {
              $_.name -match '(?i)\.msi\.zip$' -and $_.name -match '(?i)x64|x86_64|amd64'
            } | Select-Object -First 1
          }

          if (-not $updaterAsset) {
            $updaterAsset = $windowsUpdaterAssets | Where-Object {
              $_.name -match '(?i)\.msi\.zip$'
            } | Select-Object -First 1
          }

          if (-not $updaterAsset) {
            throw "No Windows updater bundle (.nsis.zip or .msi.zip) found in release $tag. Assets: $($release.assets.name -join ', ')"
          }

          # Retry: wait for GitHub to index the .sig asset in the release
          $sigName = "$($updaterAsset.name).sig"
          $sigAsset = $null

          for ($i = 0; $i -lt 12; $i++) {
            $release = Invoke-RestMethod -Headers $headers -Uri $api
            $sigAsset = $release.assets | Where-Object { $_.name -eq $sigName } | Select-Object -First 1
            if ($sigAsset) { break }
            Start-Sleep -Seconds 5
          }

          if (-not $sigAsset) {
            throw "No signature asset found for $($updaterAsset.name). Expected: $sigName. Assets: $($release.assets.name -join ', ')"
          }

          $resp = Invoke-WebRequest -Headers $headers -Uri $sigAsset.browser_download_url
          if ($resp.Content -is [string]) {
            $signature = $resp.Content.Trim()
          } else {
            $signature = [Text.Encoding]::UTF8.GetString($resp.Content).Trim()
          }

          $manifest = @{
            version = $tag.TrimStart('v')
            notes = "Beta update $tag"
            pub_date = $release.published_at
            platforms = @{
              "windows-x86_64" = @{
                signature = $signature
                url = $updaterAsset.browser_download_url
              }
            }
          } | ConvertTo-Json -Depth 8

          New-Item -ItemType Directory -Force -Path updates | Out-Null
          $manifest | Out-File -Encoding utf8 updates/beta.json

      - name: Publish updates/ to gh-pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: updates
          destination_dir: updates
          keep_files: true
